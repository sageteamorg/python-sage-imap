.. _terminologies:

IMAP Terminologies
==================

The documentation provides a solid foundation for understanding IMAP terminologies, particularly in the context of Python Sage IMAP. However, the section on Message Identification (covering Message-ID Header, UID, and Sequence Number) could be enhanced for clarity, depth, and practical application. Below is a revised version of this section that improves explanations, adds comparisons, clarifies use cases, and includes additional examples to make the concepts more accessible and actionable.

Core IMAP Concepts
-------------------

IMAP Server
~~~~~~~~~~~

**Definition**: The server that hosts your email and provides IMAP protocol access.

**What it does**:
- Stores your emails permanently
- Manages folders and mailboxes
- Handles authentication and permissions
- Processes IMAP commands (search, fetch, etc.)
- Synchronizes changes across multiple clients

**Examples**:
- Gmail: ``imap.gmail.com``
- Outlook: ``outlook.office365.com``
- Yahoo: ``imap.mail.yahoo.com``
- Corporate: ``mail.yourcompany.com``

**In Python Sage IMAP**:

.. code-block:: python

   from sage_imap.services import IMAPClient
   
   # Connect to Gmail IMAP server
   client = IMAPClient(host="imap.gmail.com", username="user@gmail.com", password="password")

IMAP Client
~~~~~~~~~~~

**Definition**: The application or library that connects to the IMAP server to access emails.

**What it does**:
- Establishes secure connections to IMAP servers
- Sends commands and receives responses
- Manages authentication and sessions
- Handles protocol-level details

**In Python Sage IMAP**:

.. code-block:: python

   # IMAPClient is your main client interface
   with IMAPClient(host="imap.example.com", username="user", password="pass") as client:
       # Client handles all protocol details for you
       print(f"Connected to: {client.host}")
       print(f"Capabilities: {client.capabilities}")

Mailbox (Folder)
~~~~~~~~~~~~~~~~

**Definition**: A container that holds email messages on the IMAP server.

**Common mailboxes**:
- **INBOX**: Default inbox for incoming mail
- **Sent**: Sent messages
- **Drafts**: Draft messages
- **Trash/Deleted**: Deleted messages
- **Custom folders**: User-created organizational folders

**Hierarchical structure**:
- Folders can contain subfolders
- Example: ``INBOX/Projects/2024/Client-A``

**In Python Sage IMAP**:

.. code-block:: python

   from sage_imap.services import IMAPMailboxService
   
   with IMAPClient(host="imap.example.com", username="user", password="pass") as client:
       mailbox = IMAPMailboxService(client)
       
       # List all folders
       folders = mailbox.list_folders()
       print("Available folders:", folders)
       
       # Select a specific folder
       mailbox.select("INBOX")
       
       # Work with subfolders
       mailbox.select("INBOX/Projects")

Message Identification
-----------------------

Understanding how messages are identified in IMAP is **critical for performing reliable and efficient operations** like fetching, moving, or deleting emails. IMAP uses three primary identifiers: Message-ID Header, UID (Unique Identifier), and Sequence Number. Each serves a distinct purpose, and choosing the right one depends on the task at hand. 

**‚ö†Ô∏è IMPORTANT: For production applications, always use UIDs for reliable message operations!**

Below, we explain each identifier, their characteristics, how they differ, and how to use them effectively in Python Sage IMAP.

Message-ID Header
~~~~~~~~~~~~~~~~~

**Definition**: The **Message-ID Header** is a globally unique identifier assigned to an email message by the sending email server, embedded in the email's headers.

**Format**: Typically follows the pattern `<unique-string@domain>`, where the `unique-string` is a combination of timestamp, random characters, or other unique data, and `domain` is the sender's domain.

**Example**: `<CABcDefGH123456789@gmail.com>` or `<20240115123045.ABC123@company.com>`

**Characteristics**:

- **Globally unique**: No two messages should have the same Message-ID across any system.

- **Immutable**: Remains constant regardless of where the message is stored or moved (e.g., between folders or servers).

- **Application**: Used for message threading (grouping replies in a conversation), deduplication (avoiding duplicate emails), and tracking messages across different systems or mailboxes.

- **Generated by**: The sending mail server (e.g., when you send an email via Gmail, Gmail assigns the Message-ID).

**Real-world Example**:

.. code-block:: python

   # Finding duplicate emails across different folders
   from sage_imap.helpers.search import IMAPSearchCriteria
   
   # Search for a specific message across all folders
   message_id = "<CABcDefGH123456789@gmail.com>"
   criteria = IMAPSearchCriteria.message_id(message_id)
   
   # Check INBOX
   uid_service.select("INBOX")
   inbox_results = uid_service.uid_search(criteria)
   
   # Check Sent folder
   uid_service.select("Sent")
   sent_results = uid_service.uid_search(criteria)
   
   print(f"Message found in INBOX: {len(inbox_results.affected_messages) > 0}")
   print(f"Message found in Sent: {len(sent_results.affected_messages) > 0}")

**Use Cases**:

- Identifying the same email across multiple systems (e.g., in Gmail and Outlook if forwarded)

- Grouping related emails in a thread (e.g., replies to an original message)

- Deduplicating emails when importing or syncing mailboxes

- Tracking email delivery and responses across different mail servers

**Limitations**:

- Not used for direct IMAP operations like fetching or deleting, as it's a header field, not an IMAP-level identifier

- Requires fetching message headers to access, which can be slower than using UIDs or sequence numbers

- Some older systems may not generate proper Message-IDs

**UID (Unique Identifier) - THE RECOMMENDED APPROACH**
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

**Definition**: The **UID (Unique Identifier)** is a unique, server-assigned number for each message within a specific mailbox, used for reliable and persistent message referencing.

**üî• WHY UIDs ARE CRUCIAL FOR RELIABLE OPERATIONS:**

- **‚úÖ Session Independence**: UIDs remain constant across different IMAP sessions and connections

- **‚úÖ Persistent**: UIDs don't change when other messages are added, deleted, or moved

- **‚úÖ Reliable**: Operations based on UIDs are predictable and stable

- **‚úÖ Efficient**: Server-optimized for UID-based operations

- **‚úÖ Synchronization**: Essential for email clients and multi-device sync

**Format**: Integer numbers (e.g., 1001, 1002, 1003, etc.)

**Characteristics**:

- **Unique within a mailbox**: Each message in a given mailbox (e.g., INBOX) has a unique UID

- **Permanent**: UIDs are not reused, even if a message is deleted (unless the mailbox is reset, which is rare)

- **Monotonically increasing**: Newer messages typically have higher UIDs, though gaps may exist due to deletions

- **Mailbox-specific**: UIDs are not valid across different mailboxes (e.g., a message moved from INBOX to Sent gets a new UID in the Sent mailbox)

- **IMAP-specific**: Assigned by the IMAP server when a message is added to a mailbox

**Real-world Example - Email Synchronization**:

.. code-block:: python

   from sage_imap.services import IMAPMailboxUIDService
   from sage_imap.helpers.search import IMAPSearchCriteria
   from sage_imap.models.message import MessageSet
   from sage_imap.helpers.enums import MessagePart
   
   # CORRECT: Using UID-based operations for reliability
   uid_service = IMAPMailboxUIDService(client)
   uid_service.select("INBOX")
   
   # Search using UIDs - ALWAYS returns UIDs
   search_result = uid_service.uid_search(IMAPSearchCriteria.since("01-Jan-2024"))
   message_uids = search_result.affected_messages
   
   print(f"Found {len(message_uids)} messages with UIDs: {message_uids[:5]}...")
   
   # These UIDs will be the same in the next session!
   # Store them in database for later processing
   for uid in message_uids:
       # Process message by UID
       msg_set = MessageSet([uid])
       fetch_result = uid_service.uid_fetch(msg_set, MessagePart.RFC822)
       
       if fetch_result.success:
           messages = fetch_result.metadata['fetched_messages']
           if messages:
               message = messages[0]
               print(f"Processing message UID {uid}: {message.subject}")
               
               # Store UID in database for future reference
               store_processed_message(uid, message.subject, message.date)

**Practical Example - Why UIDs Matter**:

.. code-block:: python

   # Scenario: Processing emails in batches across multiple sessions
   
   # Session 1 - Initial processing
   uid_service.select("INBOX")
   all_messages = uid_service.uid_search(IMAPSearchCriteria.ALL)
   unprocessed_uids = all_messages.affected_messages
   
   # Process first 100 messages
   batch_1 = unprocessed_uids[:100]
   for uid in batch_1:
       process_message(uid)
       mark_as_processed(uid)  # Store in database
   
   # --- Connection closes, time passes ---
   
   # Session 2 - Continue processing (maybe days later)
   uid_service.select("INBOX")
   
   # Get previously processed UIDs from database
   processed_uids = get_processed_uids_from_db()
   
   # Get current messages
   current_messages = uid_service.uid_search(IMAPSearchCriteria.ALL)
   current_uids = current_messages.affected_messages
   
   # Find unprocessed messages - UIDs are still valid!
   unprocessed_uids = [uid for uid in current_uids if uid not in processed_uids]
   
   print(f"Continuing with {len(unprocessed_uids)} unprocessed messages")
   
   # Process remaining messages
   for uid in unprocessed_uids:
       process_message(uid)
       mark_as_processed(uid)

**UID-Based Search Operations**:

.. code-block:: python

   # RECOMMENDED: Always use UID-based search operations
   from sage_imap.services import IMAPMailboxUIDService
   
   uid_service = IMAPMailboxUIDService(client)
   uid_service.select("INBOX")
   
   # All search operations return UIDs
   recent_uids = uid_service.uid_search(IMAPSearchCriteria.recent(7))
   unread_uids = uid_service.uid_search(IMAPSearchCriteria.UNSEEN)
   important_uids = uid_service.uid_search(IMAPSearchCriteria.FLAGGED)
   
   # Combine search results reliably
   all_important_unread = set(unread_uids.affected_messages) & set(important_uids.affected_messages)
   
   print(f"Found {len(all_important_unread)} important unread messages")

**Use Cases**:

- **Email client synchronization**: Track which messages have been downloaded

- **Batch processing**: Process large mailboxes in chunks across multiple sessions

- **Message state tracking**: Remember which messages have been processed, read, or archived

- **Reliable message operations**: Move, copy, or delete specific messages without ambiguity

- **Database integration**: Store message references that remain valid over time

**Limitations**:
- UIDs are only valid within the same mailbox. Moving a message to another folder assigns a new UID
- Requires server support for UID-based operations (most modern servers support this via `IMAP4rev1`)

Sequence Number - **AVOID FOR PRODUCTION USE**
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

**Definition**: A temporary positional identifier based on message order in the mailbox.

**‚ö†Ô∏è WARNING: Sequence numbers are unreliable and should be avoided for production applications!**

**Format**: Integer numbers starting from 1 (e.g., 1, 2, 3, etc.)

**Characteristics**:

- **Starts at 1** for the first message in the mailbox

- **Changes when messages are added/deleted** - highly volatile

- **Relative to current mailbox state** - session-specific

- **Used for positional operations** - like "get the first 10 messages"

**Why Sequence Numbers Are Problematic**:

.. code-block:: python

   # DANGEROUS: Using sequence numbers (unreliable)
   
   # Initial state in INBOX:
   # Sequence 1: UID 1001, Subject: "Welcome Email"
   # Sequence 2: UID 1002, Subject: "Meeting Reminder"  
   # Sequence 3: UID 1003, Subject: "Project Update"
   
   # Session 1: Get message at sequence 2
   regular_service = IMAPMailboxService(client)
   regular_service.select("INBOX")
   
   msg_set = MessageSet([2])  # Sequence number 2
   fetch_result = regular_service.fetch(msg_set, MessagePart.RFC822)
   if fetch_result.success:
       messages = fetch_result.metadata['fetched_messages']
       if messages:
           original_subject = messages[0].subject
           print(f"Session 1 - Sequence 2: {original_subject}")  # "Meeting Reminder"
   
   # --- Meanwhile, another client deletes the first message ---
   
   # Session 2: Try to get the same message at sequence 2
   regular_service.select("INBOX")
   
   # New state after deletion:
   # Sequence 1: UID 1002, Subject: "Meeting Reminder"  (was sequence 2)
   # Sequence 2: UID 1003, Subject: "Project Update"    (was sequence 3)
   
   msg_set = MessageSet([2])  # Same sequence number
   fetch_result = regular_service.fetch(msg_set, MessagePart.RFC822)
   if fetch_result.success:
       messages = fetch_result.metadata['fetched_messages']
       if messages:
           new_subject = messages[0].subject
           print(f"Session 2 - Sequence 2: {new_subject}")  # "Project Update" - DIFFERENT MESSAGE!

**The Problem Illustrated**:

.. code-block:: text

   Initial mailbox state:
   Sequence 1: UID 1001, Subject: "Welcome Email"
   Sequence 2: UID 1002, Subject: "Meeting Reminder"
   Sequence 3: UID 1003, Subject: "Project Update"
   Sequence 4: UID 1004, Subject: "Weekly Report"
   
   After deleting first message:
   Sequence 1: UID 1002, Subject: "Meeting Reminder"  (was sequence 2)
   Sequence 2: UID 1003, Subject: "Project Update"    (was sequence 3)
   Sequence 3: UID 1004, Subject: "Weekly Report"     (was sequence 4)
   
   After adding new message:
   Sequence 1: UID 1005, Subject: "New Urgent Message" (new message)
   Sequence 2: UID 1002, Subject: "Meeting Reminder"
   Sequence 3: UID 1003, Subject: "Project Update"
   Sequence 4: UID 1004, Subject: "Weekly Report"

**Limited Valid Use Cases**:

.. code-block:: python

   # ONLY acceptable for immediate, positional operations
   
   # Get the latest message (current session only)
   latest_msg = MessageSet(["*"])  # Last message
   fetch_result = regular_service.fetch(latest_msg, MessagePart.RFC822)
   
   # Get first 5 messages (current session only)
   first_five = MessageSet(["1:5"])
   fetch_result = regular_service.fetch(first_five, MessagePart.RFC822)
   
   # Get last 10 messages (current session only)
   last_ten = MessageSet(["*:*-9"])
   fetch_result = regular_service.fetch(last_ten, MessagePart.RFC822)

**Comparison Summary**
~~~~~~~~~~~~~~~~~~~~~~

.. list-table:: **Message Identifier Comparison**
   :header-rows: 1
   :widths: 20 25 25 30

   * - Identifier
     - Persistence
     - Scope
     - Best Use Case
   * - **Message-ID**
     - Global & Permanent
     - Across all systems
     - Threading, deduplication
   * - **UID** ‚≠ê
     - Permanent in mailbox
     - Within mailbox
     - **All IMAP operations**
   * - **Sequence Number**
     - Session only
     - Current session
     - Positional operations only

**RECOMMENDATIONS FOR PYTHON SAGE IMAP**
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

1. **‚úÖ ALWAYS use UID-based operations for reliability**:

   .. code-block:: python
   
      # CORRECT: Use UID service for all operations
      uid_service = IMAPMailboxUIDService(client)
      search_result = uid_service.uid_search(criteria)
      fetch_result = uid_service.uid_fetch(message_set, MessagePart.RFC822)
      uid_service.uid_move(message_set, target_mailbox)

2. **‚ùå AVOID sequence-based operations in production**:

   .. code-block:: python
   
      # AVOID: Regular service uses sequence numbers
      regular_service = IMAPMailboxService(client)
      search_result = regular_service.search(criteria)  # Returns sequence numbers

3. **‚úÖ Use Message-ID for cross-system operations**:

   .. code-block:: python
   
      # CORRECT: For threading and deduplication
      criteria = IMAPSearchCriteria.message_id("<specific-message-id@domain.com>")
      results = uid_service.uid_search(criteria)

4. **‚úÖ Store UIDs in databases for long-term reference**:

   .. code-block:: python
   
      # CORRECT: Store UIDs for future processing
      processed_messages = []
      for uid in message_uids:
          # Process message
          result = process_message(uid)
          
          # Store UID for future reference
          processed_messages.append({
              'uid': uid,
              'processed_at': datetime.now(),
              'status': result.status
          })
      
      # Save to database
      save_processed_messages(processed_messages)

By following these guidelines and understanding the differences between message identifiers, you'll build more reliable and efficient email processing applications with Python Sage IMAP.
